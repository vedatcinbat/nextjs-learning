************************************************************
- My Own Notes - 

* What is Next.js ?
-> Next.js is a popular React framework that enables developers to build
server-side rendered(SSR) and static websites
-> It is developed and maintained by Vercel
-> Next.js is known for its simplicity, performance, and ease of use, providing
features like automatic static optimization, static site generation(SSG), 
server-sider rendering(SSR), API routes, and more

* Why Should We Use Next.js ?
- Server-Side Rendering (SSR): Next.js allows you to render pages on the server, 
which can improve SEO and initial load performance by providing fully rendered HTML to the client.
- Static Site Generation (SSG): You can generate static HTML at build time, which can be served directly to users, 
improving performance and reducing server load.
- API Routes: Next.js provides a way to create API endpoints within the same project, simplifying the backend integration 
and allowing for a more seamless fullstack development experience.
- Image Optimization: Next.js has built-in support for image optimization, which can significantly improve 
page load times by automatically optimizing images based on the user's device.
- TypeScript Support: Next.js has built-in TypeScript support, making it easier to build and maintain large applications with type safety.



* Scenarios Where Next.js is Used and Why ?
- SEO-Driven Websites: SSR and SSG capabilities make Next.js ideal for websites where SEO is critical, 
such as blogs, marketing sites, and e-commerce platforms.

- Performance-Critical Applications: Next.js's automatic code splitting, image optimization, and static generation 
features help build highly performant web applications.

- Complex Web Applications: For applications requiring a combination of static and dynamic content, such as dashboards, 
social media platforms, and SaaS products, Next.js provides the flexibility needed to handle different rendering needs.

- E-commerce Platforms: The combination of SSR for dynamic product pages and SSG for static content like blogs or 
landing pages makes Next.js a strong choice for e-commerce websites.

- Content Management Systems (CMS): Next.js is often used with headless CMSs like Strapi, Contentful, or Sanity, 
leveraging its ability to pre-render static pages and dynamically render content as needed.


************************************************************



************************************************************************************************************************
- Course Notes -

* What is NextJS? Why would you use it?
-> Next.js is React framework
-> FullStack React Framework
-> Build fullstack apps instead of SPAs
-> React is becomeing a hybrid library
-> Using these features without a framework is tricky & typically not all you need
--> Route Setup & Handling
--> Form Submission
--> Data Fetching 
--> Authentication
--> And much more

-> Handles route setup & config 
-> Handles req & res
-> Handles data fetching & submission

* Key Features & Benefits OF Next.js
-> Fullstack Apps
--> NextJS blends frontend + backend (in the same project)
--> Advantage: Frontend and backend tasks are part of the same project

-> File-Based Routing
--> Routes are configured via the filesystem
--> Advantage: No code-based configuration or extra packages for routing required

-> Server-side Rendering 
--> By default, NextJS renders all pages on the server
--> Advantage: The finished HTML page is sent to the client (great for SEO)


* Creating a First Next.js App
> npx create-next-app@latest <folder-name>

* App Router
> app ---------> /
>>awesome ------> /awesome 
  ---- page.js -> This will rendered when '/awesome' requested
--- pages.js -> This will rendered when '/' requested
--- layout.js
---....

>awesome>page.js

export default function AwesomePage() {
    return (
        <main>
            <h1>Awesome Page</h1>
        </main>
    )
}




* Pages Router vs App Router
- Pages Router
--> Has been around for many years
--> Very stable
--> Used in many existing NextJS projects
--> Allows you to build feature-rich fullstack apps with React

- App Router
--> Introduced with NextJS 13
--> Marked as stable but still relatively new & buggy
--> Supports modern Next & React features (fullstack React apps)
--> The future of NextJS



** NextJS Essentials **
-> Routing, Pages & Components
-> Fetching & Sending Data
-> Styling, Images & Metadata


* Starting Setup
> npx create-next-app@latest <foldername>
> cd <foldername>
> npm run dev

* Understanding File-based Routing & React Server Components
-> NextJS uses files & folders to define routes 
-> Only files & folders inside the "app" folder are considered

/app 
- /about --> my-page/about
- /blog --> my-page/blog
  - /post-1 --> my-page/blog/post-1

-> React Server Components: Rendered "only on the server. Never on the client"


* Adding Another Route via the File System
-> localhost:3000/about
--> app/about folder for that and new "page.js" file


* Filenames Matter!
-> NextJS relies on reserved, special filenames
-> But the filenames only matter inside the "app" folder

page.js --> Define page content
layout.js --> Define wrapper around pages
not-found.js --> Define "Not Found" fallback page
error.js --> Define "Error" fallback page

> app/about/page.js

export deafult function AboutPage() {
    return (
        <main>
            <h1>About Page</h1>
            <p>This is about page</p>
        </main>
    )
}

> localhost:3000/about 
> GET /about 200 in 460ms
-page-
About Page
This is the about page



* Navigating Between Pages - Wrong & Right Solution
> import Link from "next/link"

return (
    .....
    <Link href="/about"></Link>
)
-> We are not leaving the application. SPA

* Working With Pages & Layouts
> about/layout.js

export const metadata = {
  title: "Create Next App - About",
  description: "Generated by create next app",
};

export default function AboutLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}

* Reserved File Names, Custom Components, How To Organize A NextJS Project
page.js => Create a new page (e.g., app/about/page.js creates a <your-domain>/about page)

layout.js => Create a new layout that wraps sibling and nested pages

not-found.js => Fallback page for "Not Found" errors (thrown by sibling or nested pages or layouts)

error.js => Fallback page for other errors (thrown by sibling pages or nested pages or layouts)

loading.js => Fallback page which is shown whilst sibling or nested pages (or layouts) are fetching data

route.js => Allows you to create an API route (i.e., a page which does NOT return JSX code but instead data, e.g., in the JSON format)


> app/page.js
import Header from "@/components/Header";

export default function Home() {
  return (
    <main>
      ** <Header />
      <p>Let's ge started!</p>
      {/* <p><a href="/about">About Us</a></p> */}
      <p><Link href="/about">About Us</Link></p>
    </main>
  );
}

> components/Header.js
export default function Header() {
    return (
        <>
            <img src="/logo.png" alt="Vercel Logo" width="200" height="200" />
            <h1>Welcome to this NextJS Course!</h1>
        </>
    );
}


* Configuring Dynamic Routes & Using Route Parameter
> app/blog/page.js

export default function BlogPage() {
    return (
        <main>
            <h1>This is Blog Page</h1>
            <Link href="/blog/post-1">Post1</Link>
            <Link href="/blog/post-2">Post2</Link>
            <Link href="/blog/something-else">Something Else</Link>
        </main>
    )
}


> app/blog/[slug] --> page.js

export default function BlogPostPage({params}) {
    const { slug } = params;
    return (
        <main>
            <h1>Blog Post Page - {slug}</h1>
            <p>This is a blog post</p>
        </main>
    )
}


1. Routing & Page Rendering
-> Understanding Routing in NextJS Applications
-> File Name Conventions & Project Structure
-> Server Components vs Client Components

* Standard Routes
--- /about
-> Folder name = route path
app/about ---> my-website.com/about

* Dynamic Routes
--- /posts/<dynamic>
-> Define dynamic segments by wrapping the folder name with []
app/posts/[slug] --> my-website.com/posts/next-is-awesome

* Layouts & Pages
- Pages
--> Created via pages.js
--> Define page content (JSX) for a route

- Layouts
--> Created via layout.js file
--> Define wrapping layout for one or more pages

  
* Handling "Not Found" Errors & Showing "Not Found" Pages
-> Parallel Routes in Next.js is a feature that allows developers to create mutliple
independent route segments that can be rendered simuleously
-> This enables better organization of complex navigation structures and enchanged the user 
experience by allowing different parts of a page to load in parallel

- Key Features of Paralel Routes in Next.js
-> Nested Routing: You can nest routes within each other, allowing for more structured and 
hierarchical URL paths
-> Route Groups: You can group related routes together
-> Loading States: Parallel Routes enable the loading of different segments 
independently, which can improve the perceived performance of your 
application by displaying parts of the page while other parts are still loading
-> Code Splitting

- Example of usage Parallel Routing in Instagram Clone
--> Scenerio: When a user navigates to a profile page, the page includes several tabs
or sections like "Posts", "Tagged", "Saved" etc
--> Benefit: Parralel Routes allows each section to load independently. This way, the 
main profile details can be displayed immediately while the other sections are still 
loading

--> Scenerio: The Explore page may have various sections like "Trending", "Reels", "Popular"
etc.
--> Benefit: Allows different sections to load in parallel, making the Explore page feel more 
responsive

--> Scenerio: When a user navigates to the notifications or messages page, there could be 
various categories or sections ("All", "Unread", "Mentions")
--> Benefit: enable each section to load independently, ensuring that the user can 
see the initial content while other sctions are still loading


* Parallel Routing Notes
-- Parallel Routing
-> Parallel routing allows you to render multiple routes at the same time
-> This can be useful for complex layouts where different parts of the page need to load different content 
independently
-> In Next.js, this can be achieved using nested routes and layout files

-- Nested Routes
-> Nested routes are that live within other routes
-> They allow for a hierarchical structure of routes which can be used to create complex layouts with multiple 
nested components
-> In Next.js, you create nested routes by placing files and directories inside app directory

-- Catch-All Routes
-> Catch-all routes are used to match any route that falls under a certain path
-> This is useful when you want to handle a variety of dynamic paths with a single component
-> In Next.js, you create a catch-all route by using square brackets with three dots inside a file name 
like [...slug].js
-> Example: /app/blog/[...slug].js
-> This route would match: /blog/a | /blog/a/b | /blog/a/b/c

-- Catch-All Fallback Routes
-> Catch-all fallback routes are similar to catch-all routes but are used to provide a fallback for 
unmatched routes
-> This is typically used in dynamic routing to handle routes that do not match any defined paths


* Server vs Client Components
-> If we want to use "usePathname()", we have to render our component on the "client" side
-> In Next.js projects, use that "client-components" as small as possible
-> Dont render all component in the client, just render where it needs, so we can decrease
the line that rendered on the client

-> In "main-header.js", we have this : 

import Link from "next/link";
import NavLink from "./nav-link";
import {pathName} from "next/navigation";

export default function MainHeader() {

  const path = usePathname();

    return (
        <header id="main-header">
            <div id="logo">
                <Link href="/">Next News</Link>
            </div>
            <nav>
                <ul>
                    <li>
                        <Link href="/news">News</Link>
                    </li>
                    <li>
                        <Link href="/archive">Archive</Link>
                    </li>
                </ul>
            </nav>
        </header>
    )
}

-> And we need to use that path for declaring active or undefined for that news-archive links

<Link href="/news"
  className={path.startsWith('/news') ? 'active' ? 'undefined'}
>News</Link>

<Link href="/archive"
  className={path.startsWith('/archive') ? 'active' ? 'undefined'}
>News</Link>

-> If we do this, we got error message that "usePathname" can be used in client-components
-> Use "use client" at top of the file

"use client"
.....
.....
export default function MainHeader() {
  const path = usePathname();

    return (
        <header id="main-header">
            <div id="logo">
                <Link href="/">Next News</Link>
            </div>
            <nav>
                <ul>
                    <li>
                        <Link href="/news"
                          className={path.startsWith('/news') ? 'active' ? 'undefined'}
                        >News
                        </Link>
                    </li>
                    <li>
                        .....
                    </li>
                </ul>
            </nav>
        </header>
    )
}

-> This is okay but we have to aware of rendering our components on the client
-> We have to create another component where we can render on the client less code
-> For that reason, we should create "nav-link.js" file on the "components" folder


- nav-link.js
*** "use client" ****
import { usePathname } from "next/navigation";
import Link .....

export default function NavLink({href, children}) {
  const path = usePathname();

  return (
    <>
      <Link 
            href={href}
            className={path.startsWith(href) ? 'active' : undefined}
        >
            {children}
        </Link>
    </>
  )
}

-> And render just that nav-link component on the client, rest of the component should be rendered 
on the server side :

- main-header.js
import NavLink from @/components/nav-link

export default function MainHeader() {
    return (
        <header id="main-header">
            <div id="logo">
                <Link href="/">Next News</Link>
            </div>
            <nav>
                <ul>
                    <li>
                        + <NavLink href="/news">News</NavLink>
                    </li>
                    <li>
                        + <NavLink href="/archive">Archive</NavLink>
                    </li>
                </ul>
            </nav>
        </header>
    )
}

-> Now <header> <div id="logo"> parts will not be rendered on the client, just NavLink will 
be rendered on the client.




* Nested Routes Inside Dynamic Routes
-> We have dynamic route in news like : >news>{slug}
-> news/will-ai-replace-humans
-> news/.......

-> If we want to return static route inside dynamic route we should create another folder inside 
dynamic folder
-> For example if we want to create image path when image has been clicked in news/.....
-> We should add another folder called "image" after [slug]
>news>[slug]>image>page.js

import { DUMMY_NEWS } from "@/dummy-news";

export default function ImagePage({ params }) {
    const newsItemSlug = params.slug;
    const newsItem = DUMMY_NEWS.find((news) => news.slug == newsItemSlug);

    if (!newsItem) {
        notFound();
    }

    return (
        <div className="fullscreen-image">
            <img src={`/images/news/${newsItem.image}`} alt={newsItem.title} />
        </div>
    )
}

-> And we should update the Link of the image that rendering on the news/.....

<Link href={`/news/${newsItem.slug}/image`}>
  <img src={`/images/news/${newsItems.image}`} alt={newsItem.title} />
</Link>


<article className="news-article">
            <header>
                +<Link href={`/news/${newsItem.slug}/image`}>
                  +<img src={`/images/news/${newsItem.image}`} alt={newsItem.title} />
                +</Link>
                <h1>{newsItem.title}</h1>
                <time dateTime={newsItem.date}>{newsItem.date}</time>
            </header>
            <p>{newsItem.content}</p>
        </article>


* Intercepting Navigation & Using Interception Routes
-> In Next.js, intercepted routes are a powerful feature that allows you to overlay 
or "intercept" a route within the current page without causing a full page reload
-> This concept is particularly useful for creating seamless user experiences where 
part of a page need to change without disrupting the overall layout or causing a ful navigation

-- Key Concepts of Intercepted Routes
-> 1. Overlay Navigation
--> Intercepted routes can be used to create overlays or modal-like experiences 
where the new content is displayed over the existing content
--> This is commonly seen in applications for things like product previews, quick views,
or modal dialogs

-> 2. Partial Page Updates
--> Instead of reloading the entire page, intercepted routes allow specific parts 
of the page to update

-> 3. URL Structure
--> The URL can change to reflect the intercepted route, providing better state 
management and allowing users to share a bookmark specific states of the application



* Combining Parallel & Intercepting Routes
-> By combining these two techniques, you can create sophisticated layouts where different parts of the page can independently update or show overlays without disrupting the entire page. This combination is especially beneficial in scenarios like:

- Dashboards: Where you have multiple widgets or panels that need to load different data simultaneously and allow for quick detail views or actions without navigating away.
- E-commerce Sites: Where you want to show product lists and allow users to quickly view product details in an overlay without leaving the product list.
- Content Management Systems (CMS): Where different sections of the admin panel need to load independently, and actions like editing or viewing details can be done via overlays.

* Navigating Programmatically
-> import {useRouter} from "next/navigation";

const router = useRouter();

<div className="modal-backdrop" onClick={router.back} />

* Using & Understanding Route Groups
-> If we want to group routes for giving different layout for each, we use () folder with the route group name like (content) (marketing)
-> Create (content) folder and move that archive and news folder to that and create layout.js and not-found.js for that content route group
-> This layout will hold for example MainHeader but homepage should not
-> For that reason, (content)>layout.js will like this : 

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <div id="page">
          <MainHeader />
          <main>
            {children}
          </main>
        </div>
      </body>
    </html>
  )
}

-> But in (marketing) route group there wont be mainHeader. There will be just children

export default function RootLayout({ children }) {
    return (
        <html lang="en">
            <body>
                {children}
            </body>
        </html>
    )
}


* Building APIs with Route Handlers
-> Building APIs with route handlers in Next.js involves creating endpoints 
within your application that can handle HTTP requests and return responses.
-> This feature is part of the Next.js API routes, which provide a way to create 
server-side API endpoints within your Next.js application

* Key Concepts
-> API Routes: API routes provide a way to create backend logic directly within your Next.js app. They are located in the pages/api directory.
-> Route Handlers: These are functions that handle incoming HTTP requests (like GET, POST, PUT, DELETE) and send appropriate responses.
-> Dynamic API Routes: You can create dynamic API routes to handle more complex scenarios, such as routes with parameters.


app/
├── api/
│   └── route.js
│   └── users.js

- route.js
export default function handler(req, res) {
    res.status(200).json({ message: 'Hello, World!' });
}

o This creates a simple API endpoint at /api/hello that responds 
with a JSON message.

- users.js
export default function handler(req, res) {
    if (req.method === 'GET') {
        // Handle GET request
        res.status(200).json({ message: 'Fetching users...' });
    } else if (req.method === 'POST') {
        // Handle POST request
        const newUser = req.body;
        res.status(201).json({ message: 'User created', user: newUser });
    } else {
        res.status(405).json({ message: 'Method not allowed' });
    }
}

o This handles both GET and POST requests at /api/users, returning different responses based on the HTTP method.

Dynamic API Routes
File Structure:
pages/
├── api/
│   └── users/
│       └── [id].js

export default function handler(req, res) {
    const { id } = req.query;
    if (req.method === 'GET') {
        // Fetch user by ID
        res.status(200).json({ message: `Fetching user with ID ${id}` });
    } else if (req.method === 'PUT') {
        // Update user by ID
        const updatedUser = req.body;
        res.status(200).json({ message: `Updating user with ID ${id}`, user: updatedUser });
    } else if (req.method === 'DELETE') {
        // Delete user by ID
        res.status(200).json({ message: `Deleting user with ID ${id}` });
    } else {
        res.status(405).json({ message: 'Method not allowed' });
    }
}

o This allows you to handle requests for specific user IDs at /api/users/[id].



* Using Middleware
-> Middleware in Next.js is a powerful feature that allows you to run code before a request 
is completed
-> Middleware is useful for various tasks such as authentication, logging, and other pre-processing
actions
-> It enables you to have fine-grained control over the incoming requests and responses

-- Key Concepts of Middlewares in Next.js
-> Middleware File Location
--> Middleware in Next.js is defined in a file named "middleware.js" or "middleware.ts" at 
the root of your project
--> This file exports a function that processes requests

-> Middleware Function
--> The middleware function takes a 'NextRequest' object and returns a 'NextResponse' object
--> You can modify the response or request, redirect the request, or perform other actions

-> Middleware Configuration
--> Middleware can be configured to run on specific routes using the "matcher" property in  
next.config.js


* Creating Middleware
1. Basics Middleware Example
- middleware.js
import { NextResponse } from "next/server"

export function middleware(req) {
    console.log(`Request URL: {req.url}`);

    return NextResponse.next();
}

2. Authentication Example
import { NextResponse } from 'next/server';
export function middleware(req) {
    const token = req.cookies.get('auth-token');

    if (!token) {
        // Redirect to login if the token is missing
        return NextResponse.redirect('/login');
    }

    // Allow the request to proceed if authenticated
    return NextResponse.next();
}


* Multiple Middlewares 

import { NextResponse } from 'next/server';

// Authentication Middleware
function authMiddleware(req) {
    const token = req.cookies.get('auth-token');
    if (!token) {
        return NextResponse.redirect('/login');
    }
    return NextResponse.next();
}

// Logging Middleware
function loggingMiddleware(req) {
    console.log('Request URL:', req.url);
    return NextResponse.next();
}

// Rate Limiting Middleware
function rateLimitMiddleware(req) {
    // Dummy rate limiting logic
    const tooManyRequests = false; // Replace with actual rate limiting logic
    if (tooManyRequests) {
        return NextResponse.json({ message: 'Too many requests' }, { status: 429 });
    }
    return NextResponse.next();
}


* Data Fetching - Deep Dive
-> Data fetching in Next.js is a fundamental aspect of building dynamic applications
-> It allows you to fetch data from various sources like API, databases or other services, 
and integrate it into your pages before rendering
-> There are several methods to hadnle data fetching, catering to different needs and 
scenerios, including static generation, server-side rendering, and client-side rendering

-- Key Methods for Data Fetching in Next.js
-> 1. Static Generation (SSG) with 'getStaticProps'
-> 2. Server-side Rendering (SSR) with 'getServerSideProps'
-> 3. Client-side Rendering (CSR) with 'useEffect' or other client-side hooks
-> 4. Incremental Static Regeneration (ISR)

---- Course Notes
-> Option1: Client-Side Data Fetching
--> For example we have a backend code with url : localhost:8080/news that returns news object
--> We can use "fetch" and "useState/useEffect" from our News component and fetch data from 
client-side component

>news>page.js
"use client" // useState and useEffect only works with "client-side components"
import {useState, useEffect} from "react";

export default NewsPage() {

    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState();
    const [news, setNews] = useState([]);

    useEffect(() => {
        async function fetchNews() {
            setIsLoading(true);
            const response = await fetch('http://localhost:8080/news');

            if(!response.ok) {
                setError('Failed to fetch news');
                setIsLoading(false);
            }

            const news = await response.json();
            setIsLoading(false);
            setNews(news);
        }

        fetchNews();
    }, [])

    if(isLoading) {
        return <div>Loading...</div>
    }

    if(error) {
        return <div>Errro while fetching news data</div>
    }

    let newsContent;

    if(news) {
        newsContent = <NewsList news={news} />
    }

    return (
        <>
            <h1>News Page</h1>
            {newsContent}
        </>
    )
}

-> Option2: Server-side Data Fetching
--> We could call API direclty from our NewsPage server-side component if we delete "use client" and 
remove all client-side related features like useState and useEffect
--> And we should call that NewsPage with async key 

export default async function NewsPage() {
    const response = await fetch('http://localhost:8080/news');

    if(!response.ok) {
        throw new Error('Failed to fetch news');
    }

    const news = await response.json();

    return (
        <>
            <h1>News Page</h1>
            <NewesList news={news} />
        </>
    )

}

-> Now we can access the details about newsLists elements from source code beacuse all data comes from 
server.
-> We are not losing any data while getting these data unlike client-side components



* Why Use A Seperate Backend? Fetching Directly From The Source
-> We can take data.db and put that in the app folder 
-> And then we can update the lib>news.js file and update the getAllNews function
-> But we need to install "better-sql3" for accessing that db and working with that db

lib>news.js
import sql from "better-sql3";

const db = sql('data.db');


export function getAllNews() {
    const news = db.prepare('SELECT * FROM news').all();
    return news;
}

-> Now we can use this "getAllNews()" function instead of using fetch from our NewsPage component

- news>page.js
...
import { getAllNews } from "@/lib/news"

export default async function NewsPage() {
    + const news = getAllNews();

    return (
        ..
    )
}

* Showing A "Loading" Fallback
-> Sometimes data is not coming fast so for that reason we have to await
-> But we dont show any response to the user, its not ui/ux
-> For simulating this, getAllNews will run async and we will execute 1sec delay for testing purpose
with new Promise

export async function getAllNews() {
    const news = await db.prepare('SELECT * FROM news').all();
    +await new Promise((resolve) => setTimeout(resolve, 1000));
    return news;
}

>news>page.js
export default async function NewsPage() {
    const news = +await+ getAllNews();
    ...
}

-> Create "loading.js" file for handling 
>news>loading.js
export default function Loading() {
    return <div>Loading...</div>;
}













************************************************************************************************************************



-------------------------------
* Topics That I will complete in Udemy *
1. Routing & Page Rendering - Deep Dive - DONE
2. Data Fetching - Deep Dive
3. Mutating Data - Deep Dive
4. Understanding & Configuring Caching
5. NextJS App Optimizations
6. User Authentication
7. Pages & File-Based Routing 
8. Page Pre-Rendering & Data Fetching 
9. Optimizating NextJS Apps
10. Adding Backend Code with API Routes (Fullstack React)
11. Working with App-wide State (React Context)
12. Deploying NextJS Apps
13. Adding Authentication
14. NextJS Summary
-------------------------------